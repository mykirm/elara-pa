"""Generic PDF extraction module for prior authorization documents.

This module provides generic PDF extraction capabilities that can be used
for any payer's documents using marker-pdf and pdfplumber.
"""

import re
import json
import os
import sys
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, date
import hashlib

# Try to import marker-pdf components (optional, will fallback to pdfplumber)
# Only use marker if explicitly needed and environment is set up
MARKER_AVAILABLE = False
try:
    # Only try marker if we're explicitly in the marker environment
    marker_env_path = '/Users/myrakirmani/Desktop/PA/pa-hypergraph-system/marker_env/lib/python3.11/site-packages'
    if marker_env_path in sys.path:
        from marker.converters.pdf import PdfConverter
        from marker.settings import Settings
        MARKER_AVAILABLE = True
except ImportError:
    MARKER_AVAILABLE = False

# Import pdfplumber for table extraction fallback (from main environment)
import pdfplumber


def convert_pdf_to_markdown(file_path: str, output_prefix: str = None) -> str:
    """Convert PDF to Markdown using marker-pdf.
    
    Args:
        file_path: Path to the PDF file
        output_prefix: Optional prefix for output files (e.g., 'uhc', 'anthem')
        
    Returns:
        Markdown text extracted from the PDF
        
    Note:
        - Uses marker-pdf convert_single_cli for high-quality extraction
        - Falls back to pdfplumber if marker fails
        - Saves raw output to data/raw/ for provenance
    """
    import subprocess
    import sys
    from pathlib import Path
    
    # Ensure file exists
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"PDF file not found: {file_path}")
    
    print(f"Converting PDF to Markdown: {file_path}")
    
    # Create output directory
    os.makedirs("data/raw", exist_ok=True)
    base_name = Path(file_path).stem
    if output_prefix:
        base_name = f"{output_prefix}_{base_name}"
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    output_dir = f"data/raw/{base_name}_{timestamp}_marker"
    
    try:
        if not MARKER_AVAILABLE:
            raise ImportError("Marker not available, using fallback")
        
        # Use marker programmatic API
        from marker.scripts.convert_single import convert_single_cli
        
        # Save original sys.argv
        original_argv = sys.argv.copy()
        
        try:
            # Set arguments for marker
            sys.argv = [
                'convert_single',
                file_path,
                '--output_dir', output_dir,
                '--output_format', 'markdown',
                '--disable_multiprocessing'  # For reliability
            ]
            
            # Run marker conversion
            print(f"   Running marker conversion to: {output_dir}")
            convert_single_cli()
            
            # Find the generated markdown file
            output_files = list(Path(output_dir).glob("*.md"))
            if not output_files:
                raise RuntimeError("No markdown file generated by marker")
            
            markdown_file = output_files[0]
            with open(markdown_file, 'r', encoding='utf-8') as f:
                markdown_text = f.read()
            
            print(f"✅ Marker conversion successful")
            print(f"   Output: {markdown_file} ({len(markdown_text):,} chars)")
            
            return markdown_text
            
        finally:
            # Restore original sys.argv
            sys.argv = original_argv
        
    except Exception as e:
        # Fallback to pdfplumber text extraction
        print(f"⚠️  Marker failed ({e}), falling back to pdfplumber...")
        
        try:
            import pdfplumber
            text_content = []
            
            with pdfplumber.open(file_path) as pdf:
                for page_num, page in enumerate(pdf.pages, start=1):
                    text = page.extract_text()
                    if text:
                        text_content.append(f"# Page {page_num}\n\n{text}\n\n")
            
            markdown_text = "\n".join(text_content)
            
            # Save fallback output
            fallback_path = f"data/raw/{base_name}_{timestamp}_fallback.md"
            with open(fallback_path, 'w', encoding='utf-8') as f:
                f.write(markdown_text)
                f.write(f"\n\n<!-- FALLBACK EXTRACTION -->\n")
                f.write(f"<!-- Used pdfplumber due to marker failure: {e} -->\n")
            
            print(f"✅ Fallback extraction successful")
            print(f"   Output: {fallback_path} ({len(markdown_text):,} chars)")
            
            return markdown_text
            
        except Exception as fallback_error:
            raise RuntimeError(f"Both marker and fallback failed: marker={e}, fallback={fallback_error}")


def extract_tables_with_pdfplumber(file_path: str, output_prefix: str = None) -> List[Dict[str, Any]]:
    """Extract tables from PDF using pdfplumber as fallback.
    
    Args:
        file_path: Path to the PDF file
        output_prefix: Optional prefix for output files (e.g., 'uhc', 'anthem')
        
    Returns:
        List of extracted tables with metadata
        
    Note:
        - Used when marker fails to properly structure tables
        - Each table includes page number and position metadata
    """
    tables_data = []
    
    try:
        with pdfplumber.open(file_path) as pdf:
            for page_num, page in enumerate(pdf.pages, start=1):
                # Extract tables from this page
                tables = page.extract_tables()
                
                for table_idx, table in enumerate(tables):
                    if table and len(table) > 0:
                        # Clean and structure the table data
                        cleaned_table = []
                        for row in table:
                            # Filter out None values and clean strings
                            cleaned_row = [
                                cell.strip() if cell else '' 
                                for cell in row
                            ]
                            if any(cleaned_row):  # Skip empty rows
                                cleaned_table.append(cleaned_row)
                        
                        if cleaned_table:
                            tables_data.append({
                                'page': page_num,
                                'table_index': table_idx,
                                'data': cleaned_table,
                                'headers': cleaned_table[0] if cleaned_table else [],
                                'rows': cleaned_table[1:] if len(cleaned_table) > 1 else []
                            })
                            
                            print(f"Extracted table from page {page_num}: {len(cleaned_table)} rows")
    
    except Exception as e:
        print(f"Error extracting tables with pdfplumber: {e}")
    
    # Save extracted tables for debugging
    if tables_data:
        base_name = Path(file_path).stem
        if output_prefix:
            base_name = f"{output_prefix}_{base_name}"
        tables_output_path = f"data/raw/{base_name}_tables.json"
        with open(tables_output_path, 'w', encoding='utf-8') as f:
            json.dump(tables_data, f, indent=2)
        print(f"Saved {len(tables_data)} tables to: {tables_output_path}")
    
    return tables_data


def extract_pdf_metadata(file_path: str) -> Dict[str, Any]:
    """Extract metadata from PDF file.
    
    Args:
        file_path: Path to the PDF file
        
    Returns:
        Dictionary containing PDF metadata
    """
    metadata = {
        'file_path': file_path,
        'file_name': Path(file_path).name,
        'file_size': os.path.getsize(file_path) if os.path.exists(file_path) else 0,
        'extraction_timestamp': datetime.now().isoformat()
    }
    
    try:
        with pdfplumber.open(file_path) as pdf:
            metadata.update({
                'num_pages': len(pdf.pages),
                'pdf_metadata': pdf.metadata if pdf.metadata else {}
            })
    except Exception as e:
        print(f"Error extracting PDF metadata: {e}")
        metadata['error'] = str(e)
    
    return metadata