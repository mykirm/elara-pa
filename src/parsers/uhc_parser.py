"""UnitedHealthcare Prior Authorization PDF Parser.

This module handles the extraction and parsing of prior-authorization rules
from UnitedHealthcare PDF documents using marker-pdf and pdfplumber.
"""

import re
import json
import os
import sys
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, date
import hashlib

# Add marker_env to path for imports
sys.path.insert(0, '/Users/myrakirmani/Desktop/PA/pa-hypergraph-system/marker_env/lib/python3.11/site-packages')

# Import marker-pdf components
from marker.converters.pdf import PdfConverter
from marker.settings import Settings

# Import pdfplumber for table extraction fallback
import pdfplumber

# Import our models
from src.models import (
    Rule, RuleType, AuthRequirement,
    CPTCode, ICDCode, State, 
    Payer, Category, Service
)


def convert_pdf_to_markdown(file_path: str) -> str:
    """Convert PDF to Markdown using marker-pdf.
    
    Args:
        file_path: Path to the PDF file
        
    Returns:
        Markdown text extracted from the PDF
        
    Note:
        - Uses marker-pdf convert_single_cli for high-quality extraction
        - Falls back to pdfplumber if marker fails
        - Saves raw output to data/raw/ for provenance
    """
    import subprocess
    import sys
    from pathlib import Path
    
    # Ensure file exists
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"PDF file not found: {file_path}")
    
    print(f"Converting PDF to Markdown: {file_path}")
    
    # Create output directory
    os.makedirs("data/raw", exist_ok=True)
    base_name = Path(file_path).stem
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    output_dir = f"data/raw/{base_name}_{timestamp}_marker"
    
    try:
        # Use marker programmatic API
        sys.path.insert(0, '/Users/myrakirmani/Desktop/PA/pa-hypergraph-system/marker_env/lib/python3.11/site-packages')
        from marker.scripts.convert_single import convert_single_cli
        
        # Save original sys.argv
        original_argv = sys.argv.copy()
        
        try:
            # Set arguments for marker
            sys.argv = [
                'convert_single',
                file_path,
                '--output_dir', output_dir,
                '--output_format', 'markdown',
                '--disable_multiprocessing'  # For reliability
            ]
            
            # Run marker conversion
            print(f"   Running marker conversion to: {output_dir}")
            convert_single_cli()
            
            # Find the generated markdown file
            output_files = list(Path(output_dir).glob("*.md"))
            if not output_files:
                raise RuntimeError("No markdown file generated by marker")
            
            markdown_file = output_files[0]
            with open(markdown_file, 'r', encoding='utf-8') as f:
                markdown_text = f.read()
            
            print(f"✅ Marker conversion successful")
            print(f"   Output: {markdown_file} ({len(markdown_text):,} chars)")
            
            return markdown_text
            
        finally:
            # Restore original sys.argv
            sys.argv = original_argv
        
    except Exception as e:
        # Fallback to pdfplumber text extraction
        print(f"⚠️  Marker failed ({e}), falling back to pdfplumber...")
        
        try:
            import pdfplumber
            text_content = []
            
            with pdfplumber.open(file_path) as pdf:
                for page_num, page in enumerate(pdf.pages, start=1):
                    text = page.extract_text()
                    if text:
                        text_content.append(f"# Page {page_num}\n\n{text}\n\n")
            
            markdown_text = "\n".join(text_content)
            
            # Save fallback output
            fallback_path = f"data/raw/{base_name}_{timestamp}_fallback.md"
            with open(fallback_path, 'w', encoding='utf-8') as f:
                f.write(markdown_text)
                f.write(f"\n\n<!-- FALLBACK EXTRACTION -->\n")
                f.write(f"<!-- Used pdfplumber due to marker failure: {e} -->\n")
            
            print(f"✅ Fallback extraction successful")
            print(f"   Output: {fallback_path} ({len(markdown_text):,} chars)")
            
            return markdown_text
            
        except Exception as fallback_error:
            raise RuntimeError(f"Both marker and fallback failed: marker={e}, fallback={fallback_error}")


def extract_tables_with_pdfplumber(file_path: str) -> List[Dict[str, Any]]:
    """Extract tables from PDF using pdfplumber as fallback.
    
    Args:
        file_path: Path to the PDF file
        
    Returns:
        List of extracted tables with metadata
        
    Note:
        - Used when marker fails to properly structure tables
        - Each table includes page number and position metadata
    """
    tables_data = []
    
    try:
        with pdfplumber.open(file_path) as pdf:
            for page_num, page in enumerate(pdf.pages, start=1):
                # Extract tables from this page
                tables = page.extract_tables()
                
                for table_idx, table in enumerate(tables):
                    if table and len(table) > 0:
                        # Clean and structure the table data
                        cleaned_table = []
                        for row in table:
                            # Filter out None values and clean strings
                            cleaned_row = [
                                cell.strip() if cell else '' 
                                for cell in row
                            ]
                            if any(cleaned_row):  # Skip empty rows
                                cleaned_table.append(cleaned_row)
                        
                        if cleaned_table:
                            tables_data.append({
                                'page': page_num,
                                'table_index': table_idx,
                                'data': cleaned_table,
                                'headers': cleaned_table[0] if cleaned_table else [],
                                'rows': cleaned_table[1:] if len(cleaned_table) > 1 else []
                            })
                            
                            print(f"Extracted table from page {page_num}: {len(cleaned_table)} rows")
    
    except Exception as e:
        print(f"Error extracting tables with pdfplumber: {e}")
    
    # Save extracted tables for debugging
    if tables_data:
        base_name = Path(file_path).stem
        tables_output_path = f"data/raw/{base_name}_tables.json"
        with open(tables_output_path, 'w', encoding='utf-8') as f:
            json.dump(tables_data, f, indent=2)
        print(f"Saved {len(tables_data)} tables to: {tables_output_path}")
    
    return tables_data


